# -*- coding: utf-8 -*-
"""Backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19fOk9VkgHff19ebLiwq5fcKx-N7AJvXf
"""

import json
from pymongo import MongoClient
from math import radians, cos, sin, sqrt, atan2
import requests

# MongoDB setup
mongo_uri = "mongodb+srv://healthdirectory:CB313cqTa1XNern3@directorycluster.zcxkz.mongodb.net/NJProviderandTransit?retryWrites=true&w=majority"
database_name = "NJProviderandTransit"
client = MongoClient(mongo_uri)
db = client[database_name]

# Walk Score API endpoint and API key
API_KEY = '657cfd13833c9d06ab8aa60725c4f885'
API_URL = 'https://api.walkscore.com/score'

# Walk Score API function
def walkScoreAPI(addressLat, addressLong):
    params = {
        'format': 'json',
        'lat': addressLat,
        'lon': addressLong,
        'wsapikey': API_KEY
    }
    response = requests.get(API_URL, params=params)

    if response.status_code == 200:
        data = response.json()
        return data.get('walkscore')
    else:
        return {"error": "Unable to retrieve data"}

# Geocode address function
def geocode_address(address):
    geocoding_url = f"https://nominatim.openstreetmap.org/search?q={address}&format=json&limit=1"
    headers = {'User-Agent': 'NJProviderRUHacks (HealthDirectory113@gmail.com)'}
    response = requests.get(geocoding_url, headers=headers)

    if response.status_code == 200 and response.json():
        location = response.json()[0]
        return float(location['lat']), float(location['lon'])
    return None, None

# Distance calculation using the haversine formula
def haversine_distance(lat1, lon1, lat2, lon2):
    R = 6371.0  # Radius of Earth in kilometers

    lat1_rad = radians(lat1)
    lon1_rad = radians(lon1)
    lat2_rad = radians(lat2)
    lon2_rad = radians(lon2)

    d_lat = lat2_rad - lat1_rad
    d_lon = lon2_rad - lon1_rad

    a = sin(d_lat / 2)**2 + cos(lat1_rad) * cos(lat2_rad) * sin(d_lon / 2)**2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))

    distance = R * c  # Distance in kilometers
    return distance * 0.621371  # Convert to miles

# Find closest bus stop using KNN approach
def distance_to_closest_bus_stop_miles(addressLat, addressLong):
    bus_stops = db.NJ_transitcollection.find(
        {"latitude": {"$exists": True}, "longitude": {"$exists": True}},
        {'latitude': 1, 'longitude': 1, 'cross_street': 1}
    )

    closest_stop = None
    min_distance = None

    for stop in bus_stops:
        # Convert latitude and longitude to float
        lat = float(stop['latitude'])
        lon = float(stop['longitude'])
        distance = haversine_distance(addressLat, addressLong, lat, lon)

        if min_distance is None or distance < min_distance:
            min_distance = distance
            closest_stop = stop

    if closest_stop:
        closest_stop['distance'] = min_distance

    return closest_stop

# Difficulty calculation function
def calculate_difficulty_index(walk_score, total_distance, bus_stop_distance,
                               max_distance=10, max_bus_stop_distance=2,
                               w1=0.5, w2=0.3, w3=0.2):
    normalized_walk_score = (100 - walk_score) / 10
    normalized_total_distance = min(total_distance / max_distance * 10, 10)
    normalized_bus_stop_distance = min(bus_stop_distance / max_bus_stop_distance * 10, 10)

    difficulty_index = (w1 * normalized_walk_score +
                        w2 * normalized_total_distance +
                        w3 * normalized_bus_stop_distance)

    return round(min(difficulty_index, 10), 2)

# Find closest provider using KNN approach
def distanceToClosestProvider(addressLat, addressLong):
    providers = db.NJ_collection.find(
        {"latitude": {"$exists": True}, "longitude": {"$exists": True}},
        {'latitude': 1, 'longitude': 1, 'name': 1, 'bio_of_org': 1, 'address': 1, 'url': 1, 'image': 1}
    )

    closest_provider = None
    min_distance = None

    for provider in providers:
        # Convert latitude and longitude to float
        lat = float(provider['latitude'])
        lon = float(provider['longitude'])
        distance = haversine_distance(addressLat, addressLong, lat, lon)

        if min_distance is None or distance < min_distance:
            min_distance = distance
            closest_provider = provider

    if closest_provider:
        closest_provider['distance'] = min_distance

    return closest_provider

# AWS Lambda handler
def lambda_handler(event, context):
    # Get the address from the event, passed by the frontend
    address = event.get('address')
    if not address:
        return {
            'statusCode': 400,
            'body': json.dumps('Address not provided')
        }

    # Geocode the provided address
    user_lat, user_lon = geocode_address(address)
    if user_lat is None or user_lon is None:
        return {
            'statusCode': 400,
            'body': json.dumps(f"Invalid address: {address}")
        }

    # Get Walk Score for the user's location
    user_walkscore = walkScoreAPI(user_lat, user_lon)

    # Calculate distances to closest provider and bus stop
    closest_provider = distanceToClosestProvider(user_lat, user_lon)
    closest_bus_stop = distance_to_closest_bus_stop_miles(user_lat, user_lon)

    # Ensure valid distances for difficulty index calculation
    if closest_provider is None:
        return {
            'statusCode': 400,
            'body': json.dumps("No providers found nearby")
        }
    if closest_bus_stop is None:
        return {
            'statusCode': 400,
            'body': json.dumps("No bus stops found nearby")
        }

    # Calculate difficulty index
    difficulty_index = calculate_difficulty_index(
        walk_score=user_walkscore,
        total_distance=closest_provider['distance'],
        bus_stop_distance=closest_bus_stop['distance']
    )

    # Prepare the response
    response = {
        'name': closest_provider.get('name'),
        'bio_of_org': closest_provider.get('bio_of_org'),
        'address': closest_provider.get('address'),
        'distance_to_user_miles': closest_provider['distance'],
        'distance_to_closest_bus_stop_miles': closest_bus_stop['distance'],
        'closest_bus_stop_cross_street': closest_bus_stop.get('cross_street'),
        'difficulty_index': difficulty_index,
        'url': closest_provider.get('url'),
        'image': closest_provider.get('image')
    }

    return {
        'statusCode': 200,
        'body': json.dumps(response)
    }